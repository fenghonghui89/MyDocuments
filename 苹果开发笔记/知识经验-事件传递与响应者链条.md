寻找hit-test view
UIApplication - UIWindow - SuperView - SubView
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
  if (self.alpha <= 0.01 || !self.userInteractionEnabled || self.hidden) {
    return nil;
  }

  BOOL inside = [self pointInside:point withEvent:event];
  UIView *hitView = nil;
  if (inside) {
    NSEnumerator *enumerator = [self.subviews reverseObjectEnumerator];
    for (UIView *subview in enumerator) {
      hitView = [subview hitTest:point withEvent:event];
      if (hitView) {
        break;
      }
    }
    if (!hitView) {
      hitView = self;
    }
    return hitView;
  } else {
    return nil;
  }
}

事件传递  
iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之 前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。

响应者链条
接收事件的initial view如果不能处理该事件并且她不是顶层的View，则事件会往它的父View进行传递。initial view的父View获取事件后如果仍不能处理，则继续往上传递，循环这个过程。如果顶层的View还是不能处理这个事件的话，则会将事件传递给它们的 ViewController，如果ViewController也不能处理，则传递给Window(UIWindow)，此时Window不能处理的话 就将事件传递给Application(UIApplication)，最后如果连Application也不能处理，则废弃该事件。

在iOS中，事件分为三类：
	·	触控事件（单点、多点触控以及各种手势操作）
	·	传感器事件（重力、加速度传感器等）
	·	远程控制事件（远程遥控iOS设备多媒体播放等）

http://www.cnblogs.com/wengzilin/p/4249847.html
CALayer 不是UIResponder的子类，这说明CALayer无法响应事件，这也是UIView和CALayer的重要区别之一。
