如果参数sender类型是id，可以把多个参数放入一个数组，然后传递过去@[参数1，参数2...]→sender

把indexpath.row转为对象时，通过强转换(id)indexpath.row是不行的，要通过NSNumber类包装成对象

判断是否是这个类或者这个类的子类的实例:[sender isKindOfClass:[NSNumber class]]
判断是否是这个类的实例：[sender isMemberOfClass:[NSNumber class]]
isSubclassOfClass:
respondsToSelector：判断某个类是否实现了某个方法

-fno-objc-arc MRC文件用在ARC项目
-fobjc-arc ARC文件用在MRC项目

NSNumber：把基本数据类型转换成对象
NSValue ：把结构体转换成对象

tag可以标记一个view 如果数组里面的元素是随机加入的，可以用tag+switch区分

superview:某view的父视图（只有一个） 可以self.superview.superview...
subviews:某view的子视图（可以有多个）

可以用for in指定判断范围

用代码创建的imageView默认交互是关闭的，如果往里面addSubView按钮等需要交互的控件，必须手动开启交互；但通过拖拽创建出来的交互是开启的，

forint循环遍历数组：如果循环过程中要操作数组（增删），操作完要break跳出循环，否则会崩溃；也可以用普通的for循环代替

CGRectIntersectsRect(bullet.frame, zomb.frame) 判断两个矩形是否交叉

系统默认cell的label和imageview的frame不能改变，如要改变要用自定义cell，且在layoutSubViews里面定义

使用scrollView时，默认两个滚动条是开启的，如果通过拖动显示超出屏幕的内容，滚动条就会出现，这时scrollView的subViews.count就会+2（两个滚动条），而不是里面的内容个数，如果不需要用到滚动条，可以通过禁用滚动条解决

属性声明时属性的名字不能为newXXXXX

把手势添加到图片中，则手势.view就是该图片，但要注意转类型，因为手势.view是UIView类型

如果需要拖动scrollView内的图片时，不能用pan手势，因为会和scrollView的拖动冲突，这时可以用长按手势longPress

把控件从一个view拖动到另外一个view时，需要转换坐标系
//把相对于self.view的一点坐标转换到相对于ediView的坐标
CGPoint newCenter = [self.view convertPoint:center toView:self.editView];

手势的state包括开始点击、改变（可理解为移动）、结束点击
手势的state虽然是枚举类型，但最好强制转型为int:(int)lpgr.state
NSLog(@"%d",panGR.state);//1-began识别成功 2-changed变化中 3-ended撤销

NSTimer可能会不断调用self(该self被navigation包含)，使self不断retain，因此就算把self pop掉self也不会dealloc，解决方法是在适当条件下停止NSTimer，如果要求该self就算被dealloc里面的个别元素继续运行，可以把该元素转移到其他类作为其他类的属性（例如AppDelegate，程序终止才会停止运行），而该self只需用属性指向该元素操作即可

内存管理需要注意：
retain strong  ：set方法里面 把原来的release 新的retain
assign weak  ：set方面里面 直接赋值

判断系统版本：[[[UIDevice currentDevice]systemVersion] floatValue] >= 7.0

storyboard-segue-点击cell跳转：连线不要用cell连线到下一个页面，最好是tableview连线到下一个界面
 NSInteger index=[[self.tableView indexPathForCell:sender]row];

把编辑模式的delet改为删除：在删除按钮的方法retuan@“删除”
scroll定时滚动scrollview-scrollRectToVisible方法

- (BOOL)containsObject:(id)anObject;判断数组中是否包含某个元素

从网上获取的网页源码或者歌词文件之类的，可以按照末尾的符号分割每一行，如源码>，每一行歌词最后都有\n
如果要截取图片地址，可以按照“\””分割网页源码

[cell layoutSubviews];//如果tableview内容较多，局部无法显示，可以手动调用cell的布局方法刷新一下，否则显示会有问题

viewDidLayoutSubViews会在有控件加入/去除的时候调用，控件位置改变的时候是不会调用的

基本类型的属性如果没被赋值 默认为0，所以用基本类型作为判断条件的时候要小心

项目导入第三方类库时要注意路径问题，例如项目创建在桌面，后来移动到另外的地方，可能会提示类库或框架找不到，这时可以到bulid setting-search，把库路径和框架路径适当加上$(SRCROOT)/…

可以存放在字典中的类型为遵守NSCopy协议的id类型


cocoaPacketAnalyzer
Axure RP Pro 7.0
http://www.qida.com

storyboard下cell正向传值
方法1：
1.cell连线到指定页面，设置segue ID
2.tvc中做如下设置：（注：如果这时用方法2，会报动画重复警告，造成传值错误）
-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([segue.identifier isEqualToString:@"changeNote"]) {
        HFChangeNoteViewController *changeNoteViewController = segue.destinationViewController;
        changeNoteViewController.noteDataIndex = [self.tableView indexPathForSelectedRow].row;
    }
}

方法2：
如果页面中已经有按钮做segue跳转到被推出页面，而点击cell后也需要跳转到该页面，但功能不一样，则cell不用连线，tvc中做如下设置：
-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    NSNumber *sender = [NSNumber numberWithInt:indexPath.row];
    [self performSegueWithIdentifier:@"changeNote" sender:sender];
}
-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([segue.identifier isEqualToString:@"changeNote"]) {
        HFChangeNoteViewController *changeNoteViewController = segue.destinationViewController;
        if ([sender isKindOfClass:[NSNumber class]]) {
            long index = [sender longValue];
            changeNoteViewController.noteDataIndex = index;
        }
    }
}


@autoreleasepool{} 放在池中的对象，都必须发送autorelease
控件的delegate，可以用代码设置，如果控件是拉在xib上，则可以拉线来实现

myview.subviews superview window

有两种按钮，一种UIButton（继承于UIView），一种UIBarButtonItem（继承于UIBarItem）
在viewWillAppear中注册通知，在viewWillDisappear中注销通知

self.navigationItem.title = @"企业文化";
self.title = @"企业文化";
self.navigationController.title = @"企业文化"

http://blog.csdn.net/tongzhitao/article/details/8569279

杰少项目
添加内容为空的判断
编辑模式只能用在有navibar的情况下

界面跳转
modal/navi/modal+协议（跳转回原界面）

数组里面的元素 类型是否要相同

self.storyboard 用在vc里面
UIStoryboard *sb = [UIStoryboard storboardWithName@“xxxx”] 用在appdelegate

scrollview含有多张图片，放大其中一张后 缩小 会回到原来的图片

代码添加的imageview要手动开启手势识别，否则任何触摸都没反应

IOS8下pickview不应该addsubview到vc.view，不应该有父视图？

navigationBar.barStyle

[[[UIApplication sharedApplication] keyWindow] insertSubview:centerView atIndex:1001];不能直接写在viewDidLoad
被添加的subview 系统旋屏无效 要自己写旋屏适配


写代码-控制好初始状态、结束状态
过程化-不可能前一步改变后一步
多看别人的代码，多自己写，感受逻辑，实现了效果再把逻辑整理


创建的控件不能显示？复制的代码是否要修改过来；属性有没有对应好；字号是否有设置


判断某控件自身是否还存在 不是用if(!self)，而应该用if(!self.superView)

objectAtIndex是否增加引用计数

加载文件夹下所有图片时，要排除隐藏文件（以.开头）

图片不显示，要么路径错，要么坐标错，要么被遮挡，要么没加入

.app目录下的文件在程序运行时不能改变

.h写readonly属性 .m写readwrite(不写也可以)属性 属性名字相同 实现读取

判断字符串为空：name isEqual:[NSNull null];

ReVeal 查看软件架构软件

/Users/hanyfeng/Library/MobileDevice/Provisioning Profiles 去掉无用的描述文件

xcode编译失败但没有报错，可以试下：
1.xcode工具栏—window—organizer—清空
2.xcode—preferences—locations—Derived Data 去到下方地址所在文件夹，清空
scrollview storyboard 黑边



svn冲突 提示xxx.xcodeproj无法解析 把== <<< 等地方删除 然后显示包文件 把mine/r111/r....删除
要在project所在文件夹创建对应文件夹，才能在项目中创建文件夹
如果提示文件冲突无法上传，找到冲突的地方，打开文件夹，会有几个.mine .rxxx .rxxx文件 删除就可以了
http://blog.csdn.net/huanghuanghbc/article/details/8559968



xib setframe无效-可能没有关闭autolayout
系统cell内嵌一个自定义view 显示异常要滑动tv才慢慢恢复 可能没有关闭autolayout 还有autoSizeing没处理好

ios sdk路径:Xcode_6.11.app ▸ Contents ▸ Developer ▸ Platforms ▸ iPhoneOS.platform ▸ Developer ▸ SDKs


http://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html iOS应用架构谈 开篇


nil、Nil、NULL、NSNull的区别 
nil：指向一个对象的空指针
Nil：指向一个类的空指针
NULL：指向其他类型（如：基本类型、C类型）的空指针
NSNull：通常表示集合中的空值
 
举例：
NSURL *url = nil;
Class class = Nil;
int *pointerInt = NULL;
NSArray *array = [NSArray arrayWithObjects:[[NSObject alloc] init], [NSNull null], [[NSObject alloc] init], [[NSObject alloc] init], nil];
 
为什么上面的array里面的空对象不直接用nil？
如果用nil，就会变成NSArray *array = [NSArray arrayWithObjects:[[NSObject alloc] init], nil,  [[NSObject alloc] init], [[NSObject alloc] init], nil];，那么数组到第二个位置就会结束。打印[array count]的话会显示1而不是4
所以[NSNull null]通常可以作为一个数组的占位符，从而是数组的count计算准确
1.selector也可以作为方法的参数，如下
- (void)dataRequest:(NSString *)url SucceedSelector:(SEL)selector
在该方法里面执行如下方法
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;
就可以达到在方法里面调用其他方法，相比平常写的更加简便

2.可以使用通知模式达到刷新页面功能，如点击某个按钮，dismissVC并发送通知，监听该通知的页面就能触发方法刷新页面，而不需要在viewWillAppear方法里面刷新


1.selector也可以作为方法的参数，如下
- (void)dataRequest:(NSString *)url SucceedSelector:(SEL)selector
在该方法里面执行如下方法
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;
就可以达到在方法里面调用其他方法，相比平常写的更加简便

2.可以使用通知模式达到刷新页面功能，如点击某个按钮，dismissVC并发送通知，监听该通知的页面就能触发方法刷新页面，而不需要在viewWillAppear方法里面刷新



如果发现断点的时候看不到变量的值，一般是NSSting的，可能是项目设置不当，查看下面的位置
build setting - code generation - optimization level - None则可以显示 fastest则不显示


不加navi、加navi（透明/不透明）

2015-11-20 02:40:58.463 testtab[2776:87110] 1l {{0, 0}, {375, 667}} {{0, 64}, {320, 435}}
2015-11-20 02:40:58.464 testtab[2776:87110] 1w {{0, 0}, {375, 667}} {{0, 64}, {320, 435}}
2015-11-20 02:40:58.469 testtab[2776:87110] 1wl {{0, 0}, {375, 554}} {{0, 64}, {320, 435}}
2015-11-20 02:40:58.469 testtab[2776:87110] 1dl {{0, 0}, {375, 554}} {{0, 20}, {375, 534}}
2015-11-20 02:40:58.972 testtab[2776:87110] 1d {{0, 64}, {375, 554}} {{0, 20}, {375, 534}}
2015-11-20 02:40:58.973 testtab[2776:87110] 1wl {{0, 64}, {375, 554}} {{0, 20}, {375, 534}}
2015-11-20 02:40:58.973 testtab[2776:87110] 1dl {{0, 64}, {375, 554}} {{0, 20}, {375, 534}}
注：
self.view的bounds在viewWillLayoutSubviews开始获取才是正确的值
self.view的frame在viewDidApperar开始获取才是正确的值

subview的bounds在viewDidLayoutSubviews开始获取才是正确的值
subview的frame在viewDidLayoutSubviews开始获取才是正确的值



ios6
screen.bounds.size:320 480
vc.view.bounds.size:320 460（会减去20stateBar）（透明或不透明都一样）
naviH:44
vc.view原点相对screen位置：透明(0,0)，不透明(0,naviH)

ios7
screen.bounds.size::320 480
vc.view.bounds.size:320 480 （透明或不透明都一样）
naviH:44
vc.view原点相对screen位置：透明(0,0)，不透明(0,naviH+stateH)

ios8
screen.bounds.size::320 480
vc.view.bounds.size:320 480 （透明或不透明都一样）
naviH:44
vc.view原点相对screen位置：透明(0,0)，不透明(0,naviH+ stateH)

在 Info.plist 中添加 NSAppTransportSecurity 类型 Dictionary。   在 NSAppTransportSecurity 下添加 NSAllowsArbitraryLoads 类型 Boolean,值设为 YES  

应用层 文件传输 电子邮件 文件服务 虚拟终端
表示层 数据格式化 数据加密
会话层 解除或建立其他节点的联系
传输层 提供端对端接口
网络层 路由
数据链路层 arp
物理层

应用层
传输层=表示层+会话层
网络层
数据链路层
物理层
