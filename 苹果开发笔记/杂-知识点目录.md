自我介绍
职业规划
为什么选择这一行

——————————————————————————————————————————

什么是设计模式—针对程序中特定的问题的解决方案
MVC—c对m：KVO/KVC 广播  c对v:IBOutlet v对c：tagret-action/delegate/datasource
单例
观察者（广播、KVC/KVO）
委托
target-action
——————————————————————————————————————————

OC与C++的区别
协议—多继承
对象是指针 对象是一个变量也可以是一个指针
运算符重载、命名空间、内联函数、构造函数、析构函数、拷贝构造函数

——————————————————————————————————————————
生命周期
内存管理
——————————————————————————————————————————

各种数值
char-1B
int-4B
float-4B
double-8B
Bool-1B

navigationBar-44
状态栏-IOS7之前20默认占用，IOS7之后20默认不占用（渗透），可隐藏；来电等特殊情况会占用40(其中20是状态栏本身，另外20占用navi)
toolBar-44
tabBar-49

分辨率
iPhone 3gs之前	320*480
iPhone 4 之后	640*960
iPhone 5 之后	640*1136
编程时只有两个尺寸320 * 480 320 * 568
——————————————————————————————————————————

UITouch触控 began/moved/ended/locationInView
手势（swipe轻扫/tap点击/pinch缩放/rotation旋转/pan拖动-state(began/changed/ended)）
——————————————————————————————————————————
IOS系统架构
cocoa touch 基本系统服务（多任务、触控输入、推送通知）和关键框架 典型：UIKit
media 提供图形音频视频技术 典型：AVFoundation /Core Graphics/OpenGL ES/Core Animation
core services 提供应用内购买 sqlite数据库和XML等技术 典型：Foundation/CoreData/CoreFoundation
core os 提供低级功能，开发中一般不使用 典型：重力加速计

UIKit框架-让好看又能动的东西 在手机上和用户可以交互
UIKit—AppKit
Core Animation—-transform/animate/autoresizing/autolayout
Core Graphic—color/BezierPath
系统/硬件
——————————————————————————————————————————

NSData/归档/Plist/CoreData之间的关系

NSData:数据对象 里面保存二进制的文件数据
data的作用：
1.网络数据传输 都用data   
2.内存当中的数据如果要保存到文件当中 也要用到data
数据持久化：
1.保存到本地文件（数据库 NSData保存到文件）
2.保存到服务器

归档
1.作用：把对象转成二进制数据（data）
 2. 应用场景： 如果涉及到对象的保存 或者对象的网络传输的时候会用到

plist-用于保存给应用提供的中小型数据-xml格式-字典或数组

CoreData是什么:是对sqlite数据库的一个封装 属于一个框架
作用: 对数据的增删改查
什么时候用： 需要用到数据的存储的时候（数据量比较大的时候）

数据库：数据库就是一个有固定格式的文件  
数据库中的数据如何保存：数据库文件中有很多的表格 在coredata中创建一个实体 系统就会自动在数据库里面 创建一个表格
plist中只能存储数组或者字典，plist本质上是一种xml文件
查看plist源码：选择plist文件-右键-open as-source code

被归档对象是数组，如果数组里面的元素是字典，修改字典里面的键值会崩溃？

Document:存放用户数据，itunse备份手机时会备份此文件夹下面的数据
tmp：存放临时文件，此文件夹下的文件会自动清理（退出应用或重启），不能保存持久化的数据
Library:
-Caches：存放缓存，itunes备份手机时不会备份（存放一些相对临时文件较重要的文件，不能保存持久化的数据）
-Preference：存放应用的配置文件，如UserDefualts操作的plist文件
*.app：存放项目的资源，如图片、文本、多媒体，即[[NSBundle mainBundle]resourcePath]

xml为封装数据的一种通用格式
——————————————————————————————————————————

FileManager与FileBundle的区别
FileManager简单的读入和读取
FileBundle能够指定读取、更新、获取偏移量、更好的对内容进行修改
——————————————————————————————————————————

哪些可以writeToFile和URL:
NSData/NSDictionary/NSArray
——————————————————————————————————————————

HTTP请求步骤：
1.创建请求地址NSString→NSRUL
2.创建请求对象NSRUL→NSMutableURLRequest
3.指定请求方式（GET/POST)
4.设置是否获取响应头NSHTTPURLResponse
5.发送请求（同步/异步）NSMutableURLRequest→NSURLConnection
6.把得到的数据转为相应类型并输出（注意编码）

——————————————————————————————————————————
HTTP/SOCKET区别
HTTP：有消息头、短连接
SOCKET：长连接

——————————————————————————————————————————

多线程
1）NSThread
优点：NSThread 比其他两个轻量级
缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销

2）Cocoa  NSOperation
优点:不需要关心线程管理， 数据同步的事情，可以把精力放在自己需要执行的操作上。
Cocoa operation相关的类是NSOperation, NSOperationQueue.
NSOperation是个抽象类,使用它必须用它的子类，可以实现它或者使用它定义好的两个子类: NSInvocationOperation和NSBlockOperation.
创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。

3) GCD(全优点)
Grand Central dispatch(GCD)是Apple开发的一个多核编程的解决方案。在iOS4.0开始之后才能使用。GCD是一个替代NSThread, NSOperationQueue,NSInvocationOperation等技术的很高效强大的技术。



——————————————————————————————————————————

内存管理  

内存分区
1、栈区（stack）— 先进后出，由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，从高到低向下增长
2、堆区（heap） — 顺序随意，一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，从低到高向上增长
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。
http://blog.csdn.net/yusongwhu/article/details/3428247
http://blog.csdn.net/youoran/article/details/10990815


深拷贝浅拷贝
浅拷贝只是复制对象本身，对象的属性和包含的对象不做复制。
深拷贝则对对象本身复制，同是对对象的属性也进行复制。
深浅拷贝的本质区别是对象或者对象属性的内存地址是否一样，一样则为浅拷贝，不一样则为深拷贝。
Foundation框架支持复制的类，默认是浅拷贝。

mrc arc
1.把mrc的代码放到arc的项目当中 需要在此类上面加上 -fno-objc-arc
2.把arc项目的代码放到mrc项目中，或者使arc代码的arc功能禁用， 需要在该类上面加上 -fobjc-arc

arc弊端
weak release地方不可判断
如果两个类有交互一个是mrc一个arc 会有莫名其妙泄露 最终解决办法是全都为mrc/arc
非OBJC对象是不会检测，不会自动添加释放语句的。比如C语言的malloc ，就得自己手动去free。
ARC并不适用于C引用。 像CoreGraphics库有C语言的接口，它们并没有调用retain和relea方法。而是使用的自己类似于retain和release方法，如 CGContextRelease（context c）来管理内存。
A类有个B类的属性 B类有个A类的属性 循环引用无法释放，解决是把其中一个为weak
动画无限循环造成vc无法被释放，解决是适当地方关掉动画
Blocks 内部使用一个实例时会retain，为了防止内存泄露。在block之前需使用_weak 若引用标示。

__strong： 赋值给这个变量的对象会自动被retain一次，如果在block中引用它，block也会retain它一次。
__unsafe_unretained： 赋值给这个变量不会被retain，也就是说被他修饰的变量的存在不能保证持有对象的可靠性，它可能已经被释放了，而且留下了一个不安全的指针。不会被block retain。 
__week：类似于__unsafe_unretained，只是如果所持有的对象被释放后，变量会自动被设置为nil，这样更安全些，不过只在IOS5.0以上的系统支持，同样不会被block retain。
__block：__block关键字修饰一个变量，表示这个变量能在block中被修改（值修改，而不是修改对象中的某一个属性，可以理解为修改指针的指向）。会被自动retain，变量最后要置nil防止循环引用。于其他变量不同的是被__block修饰的变量在块中保存的是变量的地址。（其他为变量的值）

block与循环引用
http://www.cnblogs.com/tangbinblog/archive/2012/12/31/2840690.html



——————————————————————————————————————————

ios应用程序生命周期（前后台切换，应用的各种状态）

Not running  未运行  程序没启动
Inactive          未激活        程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态
Active             激活           程序在前台运行而且接收到了事件。这也是前台的一个正常的模式
Backgroud     后台           程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态
Suspended    挂起           程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。


http://blog.csdn.net/totogo2010/article/details/8048652
