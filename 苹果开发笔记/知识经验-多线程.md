


一个程序有多个进程 一个进程至少有一个线程 同一进程下的线程共享进程的空间 线程是相当耗资源的
pc下一般多任务就是指多进程
ios跟pc不同，每个app都是单进程的，有一个主线程负责ui刷新等，但有多个子线程
次级线程异常跟主线程异常是一样的，结果都是进程被终止。即某个线程出问题，该线程所在进程就会终止。
NSException是一个可以在线程间传递的独立对象
After starting a thread, the thread runs in one of three main states: running, ready, or blocked
解决多线程下的资源共用问题 - 锁（互斥锁 递归锁） 条件 原子性
线程之间的通信 - 直接通讯Perform Selector 全局变量 条件 runloop源 端口和套接字 先进先出的低效能消息队列（已弃置） 分布式对象（高开销，更适合进程间通信，因为进程间通信已经是高开销）

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

runloop
runloop负责调度工作和协调接收事件的事件处理循环，让线程在没有什么事情做的时候睡眠，有工作做的时候忙碌，以提高线程效率
每个线程，包括应用程序的主线程，都有一个相关的runloop对象

runloop从两个源头接收事件：
input源负责异步事件 通常消息来自于其他线程或程序
  基于端口的输入源（内核发出信号）
    NSPort (CFMachPortRef, CFMessagePortRef, or CFSocketRef)
  自定义输入源（另一个线程手动发出信号）
    CFRunLoopSourceRef 多个回调函数 事件传递机制
  Cocoa Perform Selector Sources
    执行后会从runloop移除
timer源负责同步事件 通常消息来自于其他线程或程序

runloop在处理源时，会有通知产生，可以通过cf框架设置观察通知

进程是一家工厂，线程是一个流水线，Run Loop就是流水线上的主管；
当工厂接到商家的订单分配给这个流水线时，Run Loop就启动这个流水线，让流水线动起来，生产产品；
当产品生产完毕时，Run Loop就会暂时停下流水线，节约资源。
RunLoop管理流水线，流水线才不会因为无所事事被工厂销毁；
而不需要流水线时，就会辞退RunLoop这个 主管，即退出线程，把所有资源释放。

参考：
http://www.cnblogs.com/ioshe/p/5489112.html


——————————————————————————————————————————————————————————————————————————————————————————————————————————————————



多线程
1）NSThread
优点：NSThread 比其他两个轻量级
缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销

2）Cocoa  NSOperation
优点:不需要关心线程管理， 数据同步的事情，可以把精力放在自己需要执行的操作上。
Cocoa operation相关的类是NSOperation, NSOperationQueue.
NSOperation是个抽象类,使用它必须用它的子类，可以实现它或者使用它定义好的两个子类: NSInvocationOperation和NSBlockOperation.
创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。

3) GCD(全优点)
Grand Central dispatch(GCD)是Apple开发的一个多核编程的解决方案。在iOS4.0开始之后才能使用。GCD是一个替代NSThread, NSOperationQueue,NSInvocationOperation等技术的很高效强大的技术。
