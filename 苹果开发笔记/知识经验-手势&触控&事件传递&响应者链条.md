day13
{AM1}
(day12补充)
一、	手势
1.	手势与nib
[Demo_0_1]

二、	深入坐标系
1.	变态四人组
.frame				
是什么？
子视图占用父视图坐标系的空间大小
什么时候用？
当你身处父视图中（VC/V）试图做以下事情时
1.	初始化子视图的坐标信息
2.	在不使用transform/autolayout技术前提下
修改坐标信息
修改它的时候什么会被修改
1.	.size -> bounds.size
如果修改了size内部坐标系的size大小会因此被改变
2.	-> center
如果修改了frame，这个frame相对于父视图的center会因此被改变
3.	-> transform
如果该子view已经有了一定的transform,
本身不应该修改frame，而如果修改frame，会导致transform的改变
注意：
如果没有使用transform
子视图的frame.size和子视图的bounds.size 应该完全一致并且联动

.bounds
什么是？
一个视图它自己坐标系的大小
什么时候用？
取值：
当计算子视图坐标需要参照父视图的坐标系大小时
设置值：
当写View子类的时候（尤其是Cell）
视图的大小不由外部决定，而由数据决定
计算预计大小，自行修改bounds
修改它的时候什么会被修改
-> .frame.size
-> .center

.transform
什么是？
在现有frame基础之上做出变形
什么时候用？
一般在确认不使用Autolayout技术的前提下
增加各种特效
修改它的时候什么会被修改
.frame
增加变形之后，当前view相对于父view
的所占空间会产生改变
.center

.center
什么是？
中央点坐标（相对于父视图坐标系的）
什么时候用？
当使用transform后，想移动位置
如果使用frame修改就会联动transform
所以要用center修改
修改它的时候什么会被修改
-> .frame.origin


{AM1-10:28}
(day13)
三、	触控 Touch
1.	是什么？
用户和屏幕接触的信息
2.	干什么？
做绘图、涂鸦、手写板
3.	怎么用？
覆盖UIView的关于触控的消息
[Demo1]

{AM2}
[Demo2]
[Demo2练习]
[Demo3]

{PM1}
[Demo3练习]

四、	布局
1.	什么是？
安排子view如何摆放

2.	为什么？
因为屏幕尺寸会因为各种原因改变
改变过后，父视图的bounds会改变
子视图的frame应该随之改变
[Demo4]

3.	VC - 会对当前内容VC的view的尺寸产生改变的操作
1)	设备
分辨率
iPhone 3gs 之前	320*480
iPhone 4 之后		640*960
iPhone 5 之后		640*1136

编程时只有两个尺寸
320 * 480
320 * 568

2)	屏幕方向
竖屏 / 横屏
480 * 320
568 * 320

3)	状态栏
1>	可以显示/隐藏
iOS 7.0 以前(不含)
默认是显示，占用20的高度
可以设置为隐藏，就不占用20的高度

iOS 7.0 以后(含)
默认是显示，但是不占用20的高度
可以设置为隐藏，就不占用20的高度

2>	来电等特殊情况时
保持来电等特殊情况的状态，进入应用程序的时候
会占用40的高度

1.	来电				绿色
2.	开启个人热点		 蓝色
3.	录音				红色

4)	各种bar
1>	有哪些bar
navigationBar		44
tabBar				49
toolbar				44

2>	iOS 6 / iOS 7
iOS 7 之前（不含）
这些bar 默认 挤压VC的大小
但是你可以设置为透明不占用

iOS 7 之后（含）
这些bar 默认 不挤压VC的大小 （悬浮在VC上）
但是你可以设置VC为不渗透到bar的底下（bar可以占用）

5)	键盘*
高度特别不确定 ?


528
440
280
(0 -20 -40) * 3
(0 -44 -88 -49 -93 -137) * 6
* n

4.	VC - 做什么？
根据新尺寸，重新计算子view的frame

5.	VC - 纯代码布局
[Demo5]
viewDidLayoutSubviews

{PM2}
练习(别忘了关掉Autolayout!)
1.	两个等宽的按钮（按钮高40）
--------------------------------
|        20          20        |
|-20-[button1]-10-[button2]-20-|

2.	一个变化的UIImageView(内有照片)
imageView上下左右永远保持 70 50 20 20

3.	三个操作按钮（大小都是20x20）永远排列在右下角
[b1]-10-[b2]-10-[b3]-20-|
20                     |
------------------------
[Demo6]		 

6.	VC - iOS 7 大小问题
[Demo7]
.topLayoutGuide length
获取在渗透navi的前提下，navi＋状态条的高度

.edgesForExtendedLayout = UIRectEdgeNone;
设置vc不渗透到navi以及tabbar的底下

7.	V - VC 的布局 会导致 子View的大小改变
[Demo8]
1.	contentMode
这个属性决定着当一个view的大小在运行时被修改的情况下，
做出什么反应

默认Scale To Fill 强拉

如果是UIImageView 我们一般选择
Aspect Fit/ Aspect Fill

如果是自定义的有绘制的UIView的
需要设置为 Redraw






作业
1.	绘图板
做一个绘图板，支持多根线
TRDrawView:UIView
+	lines:NSMutableArray
+	[item]:TRDrawLine
+	currentLineWith:float
+	currentLineColor:UIColor

TRDrawLine:NSObject
+	points:NSMutableArray
+	[item]:TRDrawPoint
+	lineWidth:float
+	lineColor:UIColor

TRDrawPoint:NSObject
+	x:CGFloat
+	y:CGFloat

1.	先能画出一根线
2.	能画出多根线
3.	增加slider能调线宽
4.	增加三个slider或者调色块按钮 支持能调线颜色
5.	增加橡皮(画巨宽的白线)

0 255
0 64 128 192 256
0 63 127 191 255
0 127 255

0 0 0 0 0 127 0 0 255
0 127 0 0 127 127

0 0 0  0 0 64 0 0 127 0 0 191 0 0 255 64
0 64 0 0 64 64 0 64 127


day12
{AM1}
<CP>
一、手势
	1.	是什么？
		view层对用户触摸屏幕的行为的包装

	2.	分什么？
		一次性
		手势形成后，一次性发出事件（1个）
		Tap					点按
		Swipe				轻扫

		连续性
		手势形成后，到结束之前，持续性发出事件
		LongPress			长按
		Pan					拖动
		Rotation			旋转
		Pinch				捏/拨/掰

	3.	如何使用？
		1)	用户的手势行为需要手势识别器去识别
		2)	view层除了可以addSubview，还可以add手势识别器
			增加的手势识别器只识别这个view区域内的手势
		3)	所有的手势识别器都是继承UIGestureRecognizer类
			子类都叫UIXxxxxxGestureRecognizer

	4.	基本步骤
		1)	构建
		2)	修改
		3)	加入

	5.	UITapGestureRecognizer
		[Demo1]
		.numberOfTapsRequired
		.numberOfTouchesRequired

		用处：
			可以让任何view瞬间变button

	6.	UIPinchGestureRecognizer
		[Demo2]
		scale
		[G01]
		[练习：老板手势]
			.hidden
			界面中央有一个label，label有文字
			当两个手指头捏合，label消失
			当两个手指头拨掰，label显示

{AM2}
	7.	UIRotationGestureRecognizer
		[Demo3]
		rotation

二、	变形(Transform)
	1.	基础
		任何view都有一个属性叫做.transform

	2.	干什么
		transform 负责描述 子view的坐标系在父view坐标系上的变化

		transform的调整知作用于子view在父view上的显示
		而子view的坐标系以及子view的子view并不会因此产生改变

	3.	能改什么？
		view的角度
		view的缩放
		view的位移

	4.	transform内部
		是一个 3*3 的矩阵

		如果你想修改，可以通过一些函去修改
		每一次调用这些函数去修改，都是修改矩阵内的值

	5.	如何使用？
		.frame = CGRectMake(...);

		.transform = XXXXXXXXXMakeXXXX
		[Demo4]

		注意：
			1.	一定要关掉Autolayout！！！

		创建transform
			CGAffineTransformMakeRotation
			CGAffineTransformMakeScale
			CGAffineTransformMakeTranslation

		修改transform
			对比
			错：
			self.imageView.frame = CGRectMake(....);
			....
			self.imageView.frame = CGRectMake(....);

			对：拿出来，改一改，放回去
			CGRect frame = self.imageView.frame;
			frame.origin.x += 10;
			self.imageView.frame = frame;

			transform
			错误：
			self.imageView.transform = CGAffineTransformMakeRotation(M_PI_4);
    		self.imageView.transform = CGAffineTransformMakeScale(0.5, 0.5);

    		对：拿出来，改一改，放回去
    		CGAffineTransform transform = self.imageView.transform;
    		transform = CGAffineTransformScale(transform, 0.5, 0.5);
    		self.imageView.transform = transform;

    		[Demo4：叠加]
    		[Demo3：叠加]
    		CGAffineTransformRotate
			CGAffineTransformScale
			CGAffineTransformTranslate
			第一个参数是你要变化的原有transform
			返回值是叠加效果后的新的transfrom
			原有的transform传参后并不会被改变

	6.	交互设置
		不是所有的视图都默认接收用户交互的事件
		部分视图比如UIImageView默认不接收用户交互事件
		这个时候 即便增加了手势识别器也无用
		需要在xib中开启或在代码中设置属性
		User Interaction Enabled
		imageView.userInteractionEnabled

	6.	UIPanGestureRecognizer
		[Demo5]
			获取到位移信息
			[translationInView:];
			清空现有位移信息
			[panGR setTranslation:CGPointZero inView:self.view];

	7.	手势状态
		.state
		Began			识别成功
		Changed			手势变化中
		Ended			手势撤销/结束



	{PM2}
		[练习：图片查看器]
		要求
		1.	使用代码向view内添加一张UIImageView
			UIImageView的大小和图片本身的大小一样
		2.	使用center属性将UIImageView移动到屏幕中央
		3.	使用transform将UIImageView
			缩放到屏幕刚好能显示所有内容，而且不损失宽高比
			CGAffileTransformMakeScale(,);（参照C层Day05-Demo1）
		4.	对UIImageView增加rotation手势识别 支持旋转
			imageView.userInteractionEnabled = YES;
		5.	对UIImageView增加pinch手势识别 支持缩放（scale的还原值是1）
		6.	对UIImageView增加pan手势识别 支持拖动位移（center）
		7.	对UIImageView增加tap手势识别 双击恢复原状（3之后的）
			[UIView animateWithDuration:0.5 animation:^{
				self.imageView.center = center;
			}];	!!!!每做完一步都立刻运行测试与预期是否相符!!!   

	{PM3}
	[Demo6]
	8.	手势识别器的同时识别


三、	深入坐标系
1.变态四人组
		.frame
		.bounds
		.transform
		.center

		1)	修改frame
			会导致bounds center transform联动

		2)	修改transform
			会导致 frame  center 联动

		3)	修改bounds
			会导致frame center的联动

		4)	修改center
			会导致frame的联动


			UITouch触控 began/moved/ended/locationInView
			手势（swipe轻扫/tap点击/pinch缩放/rotation旋转/pan拖动-state(began/changed/ended)）

************************************************************************************************************************************************
************************************************************************************************************************************************


寻找hit-test view
UIApplication - UIWindow - SuperView - SubView
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
  if (self.alpha <= 0.01 || !self.userInteractionEnabled || self.hidden) {
    return nil;
  }

  BOOL inside = [self pointInside:point withEvent:event];
  UIView *hitView = nil;
  if (inside) {
    NSEnumerator *enumerator = [self.subviews reverseObjectEnumerator];
    for (UIView *subview in enumerator) {
      hitView = [subview hitTest:point withEvent:event];
      if (hitView) {
        break;
      }
    }
    if (!hitView) {
      hitView = self;
    }
    return hitView;
  } else {
    return nil;
  }
}

事件传递  
iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之 前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。

响应者链条
接收事件的initial view如果不能处理该事件并且她不是顶层的View，则事件会往它的父View进行传递。initial view的父View获取事件后如果仍不能处理，则继续往上传递，循环这个过程。如果顶层的View还是不能处理这个事件的话，则会将事件传递给它们的 ViewController，如果ViewController也不能处理，则传递给Window(UIWindow)，此时Window不能处理的话 就将事件传递给Application(UIApplication)，最后如果连Application也不能处理，则废弃该事件。

在iOS中，事件分为三类：
	·	触控事件（单点、多点触控以及各种手势操作）
	·	传感器事件（重力、加速度传感器等）
	·	远程控制事件（远程遥控iOS设备多媒体播放等）

http://www.cnblogs.com/wengzilin/p/4249847.html
CALayer 不是UIResponder的子类，这说明CALayer无法响应事件，这也是UIView和CALayer的重要区别之一。
