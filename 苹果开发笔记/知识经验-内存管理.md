

栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。
优点是快速高效，缺点时有限制，数据不灵活。［先进后出］
栈空间分静态分配 和动态分配两种
其操作方式类似于数据结构中的栈，从高到低向下增长
```
静态分配是编译器完成的，比如自动变量(auto)的分配。
动态分配由alloca函数完成。
栈的动态分配无需释放(是自动的)，也就没有释放函数。
为可移植的程序起见，栈的动态分配操作是不被鼓励的！
```

堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。
优点是灵活方便，数据适应面广泛，但是效率有一定降低。［顺序随意］
分配方式倒是类似于链表，从低到高向上增长
```
堆是函数库内部数据结构，不一定唯一。
不同堆分配的内存无法互相操作。
堆空间的分配总是动态的
```

全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。
```
注意：全局区又可分为未初始化全局区：
     .bss段和初始化全局区：data段。
     举例：int a;未初始化的。int a = 10;已初始化的。
```

文字常量区 存放常量字符串，程序结束后由系统释放

程序代码区 存放函数的二进制代码


例子代码
```
int a = 10;  全局初始化区
  char *p;  全局未初始化区

 main{
   int b; 栈区
   char s[] = "abc" 栈
   char *p1; 栈
   char *p2 = "123456";  123456\\\\0在常量区，p2在栈上。
   static int c =0； 全局（静态）初始化区

   w1 = (char *)malloc(10);
   w2 = (char *)malloc(20);
   分配得来得10和20字节的区域就在堆区。
 }
```

高地址 -> 低地址
栈 堆 全局区 常量区 代码区

ios堆栈介绍
http://mikixiyou.iteye.com/blog/1595230
http://www.jianshu.com/p/f3c1b920e8eb

************************************************************************************************************************************************
************************************************************************************************************************************************

基本原理

采用alloc/new/copy/mutableCopy所创建的对象，要release/autorelease
如果方法的返回值是一个对象，这个对象要放入自动释放池；类方法创建的对象，系统会自动放入自动释放池
方法的实参不用release，可以认为系统把实参放入自动释放池
创建单例的方法中，单例不能release/autorelease



页面跳转中，present/push一个vc后，系统会在dismiss/pop里负责释放，无需为present/push release一次
添加控件中，addSubviews（或insertSubview: atIndex:）一个控件后，系统会在[super dealloc]里负责释放释放里面的subviews（对里面的所有subviews发送一次release消息），也可以通过[xxx removeFromSuperview]释放指定控件（对里面的所有subviews发送一次release消息），无需为addSubviews（或insertSubview: atIndex:）release一次



属性的作用：1.提升作用域 2.延长生命周期（属性的生命周期最多只能延长到对象dealloc，所以最终需要在dealloc中release）
dealloc中属性的写法：
```
[_xxx release];
_xxx = nil;
```
注：delegate关键字为assign，所以无需release，置nil即可
注：尽量不要用self.xxx，因为self.xxx = nil调用set方法（前提：属性关键字是retain/copy），会先release再置nil，容易迷惑



delegate的正确置nil写法：委托方和被委托方的dealloc都要置nil



只需要为alloc/copy/retain进行release;其他诸如present/push/addSubviews等，只需要在适当地方写上对应的dismiss/pop/[super dealloc]即可，系统在执行这些语句后负责释放内存，无需写release.



如果在一个方法里面创建一个自定义网络请求类的对象，发送获取数据的消息，则不能在这个方法release这个对象，必须把该对象提升为属性，在dealloc中release。




内存泄露：一个对象或变量在使用完成后没有释放掉
僵尸对象：过度释放对象


************************************************************************************************************************************************
************************************************************************************************************************************************


响应内存警告


```
AppDelegate
- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application
{
    NSLog(@"AppDelegate中调用applicationDidReceiveMemoryWarning:");
}


ViewController
- (void)didReceiveMemoryWarning
{
    NSLog(@"ViewController中didReceiveMemoryWarning调用");
    [super didReceiveMemoryWarning];

   //释放成员变量，注意要放在[super didReceiveMemoryWarning];之后
    [_listTeams release];
}
```

其他
监听通知UIApplicationDidReceiveMemoryWarningNotification

模拟器模拟内存警告：硬件—模拟内存警告

************************************************************************************************************************************************
************************************************************************************************************************************************

把mrc的代码放到arc的项目当中 需要在此类上面加上 -fno-objc-arc
把arc项目的代码放到mrc项目中，或者使arc代码的arc功能禁用， 需要在该类上面加上 -fobjc-arc

内存管理需要注意：
retain strong  ：set方法里面 把原来的release 新的retain
assign weak  ：set方面里面 直接赋值

深拷贝浅拷贝
浅拷贝只是复制对象本身，对象的属性和包含的对象不做复制。
深拷贝则对对象本身复制，同是对对象的属性也进行复制。
深浅拷贝的本质区别是对象或者对象属性的内存地址是否一样，一样则为浅拷贝，不一样则为深拷贝。
Foundation框架支持复制的类，默认是浅拷贝。

arc弊端
weak release地方不可判断
如果两个类有交互一个是mrc一个arc 会有莫名其妙泄露 最终解决办法是全都为mrc/arc
非OBJC对象是不会检测，不会自动添加释放语句的。比如C语言的malloc ，就得自己手动去free。
ARC并不适用于C引用。 像CoreGraphics库有C语言的接口，它们并没有调用retain和relea方法。而是使用的自己类似于retain和release方法，如 CGContextRelease（context c）来管理内存。
A类有个B类的属性 B类有个A类的属性 循环引用无法释放，解决是把其中一个为weak
动画无限循环造成vc无法被释放，解决是适当地方关掉动画
Blocks 内部使用一个实例时会retain，为了防止内存泄露。在block之前需使用_weak 若引用标示。

__strong： 赋值给这个变量的对象会自动被retain一次，如果在block中引用它，block也会retain它一次。
__unsafe_unretained： 赋值给这个变量不会被retain，也就是说被他修饰的变量的存在不能保证持有对象的可靠性，它可能已经被释放了，而且留下了一个不安全的指针。不会被block retain。 
__week：类似于__unsafe_unretained，只是如果所持有的对象被释放后，变量会自动被设置为nil，这样更安全些，不过只在IOS5.0以上的系统支持，同样不会被block retain。
__block：__block关键字修饰一个变量，表示这个变量能在block中被修改（值修改，而不是修改对象中的某一个属性，可以理解为修改指针的指向）。会被自动retain，变量最后要置nil防止循环引用。于其他变量不同的是被__block修饰的变量在块中保存的是变量的地址。（其他为变量的值）

block与循环引用
http://www.cnblogs.com/tangbinblog/archive/2012/12/31/2840690.html
￼
