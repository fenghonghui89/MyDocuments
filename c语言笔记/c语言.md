
# auto

- 当修饰局部变量的时候加上auto(默认)，多次调用函数值没有累加
- 不可以修饰全局变量

# static

- 当修饰局部变量的时候加上static(静态变量)，多次调用函数值有累加的
- 修饰全局变量和函数时，被修饰的全局变量和函数的作用域在当前文件中

# extern

- a.h已经公开并用extern修饰 - input头文件就可以用（推荐）
- a.h没有公开 - 在b.c中，要使用extern关键字声明全局变量才可使用，并且可以得到全局变量的值

# 联合和枚举的区别

- 联合的用法、语法和结构非常相似，但联合中所有成员分配的是同一块内存（最大成员的内存容量）,用同一块内存对应多种类型
- 联合与结构的区别，结构可以保存多个成员的值，联合只能保存一个值

#  编译与执行的详细流程

1. 编写代码阶段，得到main.m / a.c / a.h ...
2. 预处理阶段，主要对包含的头文件和宏定义进行处理，得到xxx.i文件
    - gcc -E main.m -o main.i （只进行预编译，不做其他处理）
    - gcc -E a.c -o a.i
3. 编译阶段，检查代码规范性及语法是否有错误等，无误后生成汇编代码xxx.s文件
    - gcc -S main.i -o main.s （只进行预编译和编译，不汇编）
    - gcc -S a.i -o a.s
4. 汇编阶段，从汇编代码生成xxx.o目标文件
    - gcc -c main.s -o main.o（只进行预编译、编译、汇编，不进行链接）
    - gcc -c a.s -o a.o
    - 或者使用汇编器命令：as main.s -o main.o
5. 链接阶段，连接库函数和其他目标文件，得到可执行程序a.out（默认）
    - gcc main.o a.o -o hello.out
6. 执行程序，把a.out加载到内存当中
    - ./hello.out
7. cpu到内存里执行代码


# 基本数据类型
- c89没有定义bool，所以要```#include <stdbool.h>```才能有bool类型
- 64位系统下常用基本数据类型的资料如下：

标识符|占用空间(byte)|取值范围
:-|:-|:-
shot int|2|－32768~+32767，即-2^15~+2^15-1
int|4|-2147483648~2147483647，即-2^31~+2^31-1
long|8|-9223372036854775808~9223372036854775807，即-2^63~+2^63-1
long long|8|-9223372036854775808~9223372036854775807，即-2^63~+2^63-1
float|4|-3.40E+38~+3.40E+38，即-2^128~+2^128
double|8|-1.79E+308~+1.79E+308，即-2^1024~+2^1024
long double|16|-1.20E+4932~+1.20E+4932
char|1 |-128~127，即-2^7~+2^7-1

# 运算符

- 如果表达式有两个或相同优先级的运算符，则按结合性判断先执行谁，例如a=b=c，=是右结合性，先算b=c,再算a=b

![](http://o9ivu69va.bkt.clouddn.com/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png)
